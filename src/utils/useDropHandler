import { useState, useCallback } from "react";
import { v4 as uuidv4 } from "uuid";

const useDropHandler = (findElementById, elements, setElements, addNewElement) => {
  // activeDrop holds the container id + index for the drop placeholder.
  const [activeDrop, setActiveDrop] = useState({ containerId: null, index: null });
  // draggedItem holds the entire item being dragged.
  const [draggedItem, setDraggedItem] = useState(null);

  // Attach drop handler to a node.
  const drop = useCallback(
    (node) => {
      if (!node) return;
      const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        onDrop(e, activeDrop.containerId);
      };
      node.addEventListener("drop", handleDrop);
      return () => {
        node.removeEventListener("drop", handleDrop);
      };
    },
    [activeDrop.containerId]
  );

  const onDragStart = (e, item) => {
    e.stopPropagation();
    setDraggedItem(item);
    // Set dragged id if available.
    e.dataTransfer.setData("text/plain", item.id || "");
    // (Optional ghost image creation)
    const dragImage = document.createElement("div");
    dragImage.style.position = "absolute";
    dragImage.style.top = "-1000px";
    dragImage.style.left = "-1000px";
    dragImage.style.padding = "4px 8px";
    dragImage.style.background = "#fff";
    dragImage.style.border = "1px solid #ccc";
    dragImage.style.fontSize = "inherit";
    dragImage.innerHTML = e.currentTarget.innerHTML;
    document.body.appendChild(dragImage);
    e.dataTransfer.setDragImage(
      dragImage,
      dragImage.offsetWidth / 2,
      dragImage.offsetHeight / 2
    );
    setTimeout(() => {
      document.body.removeChild(dragImage);
    }, 0);
  };

  const onDragOver = (e, containerId, index) => {
    e.preventDefault();
    e.stopPropagation();
    // Update drop placeholder if different.
    if (activeDrop.containerId !== containerId || activeDrop.index !== index) {
      setActiveDrop({ containerId, index });
    }
  };

  const onDrop = (e, containerId) => {
    e.preventDefault();
    e.stopPropagation();
    if (!activeDrop) return;
    const dropIndex = activeDrop.index;
    if (dropIndex === null) return;
    const container = findElementById(containerId, elements);
    if (!container) return;

    if (draggedItem && !draggedItem.id) {
      // New item: create element.
      addNewElement(draggedItem.type, draggedItem.level || 1, null, containerId);
    } else if (draggedItem && draggedItem.id) {
      // Existing item: find its current container.
      const oldContainer = elements.find(el => el.children?.includes(draggedItem.id));
      if (!oldContainer) {
        // Fallback: treat as new.
        addNewElement(draggedItem.type, draggedItem.level || 1, null, containerId);
      } else if (oldContainer.id === containerId) {
        // Reorder within same container.
        const newChildren = [...container.children];
        const originalIndex = newChildren.indexOf(draggedItem.id);
        newChildren.splice(originalIndex, 1);
        const correctedIndex = originalIndex < dropIndex ? dropIndex - 1 : dropIndex;
        newChildren.splice(correctedIndex, 0, draggedItem.id);
        setElements(prev =>
          prev.map(el =>
            el.id === containerId ? { ...el, children: newChildren } : el
          )
        );
      } else {
        // Dropped into a different container: clone the element.
        const draggedElement = findElementById(draggedItem.id, elements);
        if (!draggedElement) return;
        const newId = uuidv4();
        const clonedElement = { ...draggedElement, id: newId, children: [] };
        setElements(prev => [...prev, clonedElement]);
        const newChildren = [...container.children];
        newChildren.splice(dropIndex, 0, newId);
        setElements(prev =>
          prev.map(el =>
            el.id === containerId ? { ...el, children: newChildren } : el
          )
        );
      }
    }
    setActiveDrop({ containerId: null, index: null });
    setDraggedItem(null);
  };

  const onDragEnd = () => {
    setActiveDrop({ containerId: null, index: null });
    setDraggedItem(null);
  };

  return { activeDrop, draggedItem, onDragStart, onDragOver, onDrop, onDragEnd, drop };
};

export default useDropHandler;
